# Orchestr8: IIIT Kota Container Orchestrator

## Technical Documentation & Deployment Guide

**Orchestr8** is a lightweight, custom Platform-as-a-Service (PaaS) solution designed to simplify the deployment of multiple Dockerized applications on a single server. It automates the complexity of Nginx reverse proxy configuration, SSL termination, and Docker container management, effectively turning a raw Linux server into a powerful deployment hub.

<img width="768" height="512" alt="image" src="https://github.com/user-attachments/assets/e5a3048a-904b-456c-aff6-c96a50b85cbd" />



This backend service interacts directly with the Docker Daemon and Nginx CLI to provide a seamless "Push-to-Deploy" experience similar to Vercel or Heroku, but for self-hosted infrastructure.

<img width="958" height="578" alt="image" src="https://github.com/user-attachments/assets/0d970fdf-3dc4-47da-ad4e-53678062496e" />


---

### 1. System Architecture & Prerequisites

The platform is built on the **Bun runtime** for high performance and native TypeScript support. It utilizes **Hono** for the API framework and **SQLite** for granular permission management.

**Core Components:**

**Dockerode:** A Node.js library used to communicate with the Docker Socket (`/var/run/docker.sock`), allowing the API to start, stop, and inspect containers.
**Nginx Manager:** A custom module that generates Nginx server blocks dynamically and reloads the service without downtime.
**SQLite DB:** Stores user credentials and role-based access control (RBAC) data locally.



**Prerequisites:**

* Linux Server (Arch Linux/Ubuntu/Debian based recommended)
* [Bun Runtime](https://bun.sh/) (v1.0+)
* Docker & Docker Compose (v2.0+)
* Nginx (Mainline/Stable)

---

### 2. Server-Side Installation

#### Step 1: Clone and Install

Clone the repository to your production server and install dependencies.

```bash
git clone https://github.com/s4tyendra/orchestr8.git
cd orchestr8
bun install && bun run build

```

#### Step 2: Nginx Directory Preparation

The application requires a dedicated directory to write Nginx configurations. Standard Nginx directories are often root-owned, so we create a specific directory with appropriate permissions to avoid running the entire application as root.

```bash
# 1. Create the managed directory
sudo mkdir -p /etc/nginx/sites-available/api-managed

# 2. Assign ownership to the user running the orchestrator (e.g., 'ubuntu' or 'satya')
sudo chown -R $USER:$USER /etc/nginx/sites-available/api-managed

# 3. Create the SSL snippet


sudo mkdir -p /etc/nginx/snippets

```

*Technical Note:* The application checks `CONFIG.PATHS.NGINX_MANAGED_DIR` to determine where to write files.

#### Step 2.1 SSL configuuration
Prepare wild card domain config as shown in image below. (if using cloudflare, temporarily disable proxy)
<img width="768" height="512" alt="image" src="https://github.com/user-attachments/assets/ab4fc33e-faa1-41de-a8f7-07f61bd36f67" />

* 1. Install Certbot

If not installed:

```bash
# Ubuntu/Debian
sudo apt update && sudo apt install certbot python3-certbot-nginx

# Arch
sudo pacman -S certbot certbot-nginx
```

* 2. Generate Certificate

Run this to generate the cert files (stored in `/etc/letsencrypt/live/`) without modifying your Nginx config yet:

```bash
sudo certbot certonly --nginx -d cname.domain.tld
```
*replace cname.domain.tld from the domain you configured*

* 3. Create Nginx Snippet

Put the **configuration directives** files in `/etc/nginx/snippets`.

Create the file:

```bash
sudo mkdir -p /etc/nginx/snippets
sudo nano /etc/nginx/snippets/ssl-cname.domain.tld.conf

```

Paste this content (replace `cname.domain.tld` with your actual domain):

```nginx
ssl_certificate /etc/letsencrypt/live/cname.domain.tld/fullchain.pem;
ssl_certificate_key /etc/letsencrypt/live/cname.domain.tld/privkey.pem;
include /etc/letsencrypt/options-ssl-nginx.conf;
ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;
```

### 4. Configure Nginx Server Block

Edit your domain's config file (e.g., `/etc/nginx/sites-available/cname.domain.tld`):

```nginx
server {
    listen 443 ssl;
    server_name cname.domain.tld;

    # Import the snippet
    include /etc/nginx/snippets/ssl-cname.domain.tld.conf;

    location / {
        return 404
    }
}

```

*Test and reload:*

```bash
sudo nginx -t
sudo systemctl reload nginx

```
> * Now, you may enable proxy in cloudflare 


#### Step 3: Include Managed Configs in Nginx

Edit your main `nginx.conf` to include the configurations generated by Orchestr8.

```nginx
http {
    # ... existing config ...
    include /etc/nginx/sites-available/api-managed/*.conf;
}

```

---

### 3. Configuration & Environment Variables

Create a `.env` file in the project root. This file is critical for authentication and GitHub Container Registry (GHCR) integration.

```ini
# Server Port (Default: 8080)
PORT=8080

# Super Admin Credentials (Environment-based fallback)
AUTH_USERNAME=admin
AUTH_PASSWORD=secure_password_here

# GitHub Integration (CRITICAL)
# Required to fetch image tags and versions from GHCR
GITHUB_PAT=ghp_xxxxxxxxxxxxxxxxx
DOCKER_USERNAME={your docker/github username}

# CORS Configuration
ALLOWED_ORIGINS=http://localhost:5173,https://orchestr8-ui.devh.in

```

**Technical Details for `GITHUB_PAT` **

The system uses the GitHub Personal Access Token (PAT) for two distinct purposes:

1. **Docker Registry Authentication:** It serves as the password when the backend performs a `docker login` to pull private images.
2. **API Metadata:** It authenticates requests to the GitHub API to fetch the latest image tags (versions) and available packages. Without this, the UI cannot show "Available to Install" services.



---

### 4. Role-Based Access Control (RBAC) System

Orchestr8 implements a granular permission system stored in SQLite. This allows you to give specific users access to specific containers without granting full admin rights.

**Permission Structure:**
A permission consists of a **Scope** and an **Action**.

| Scope | Description |
| --- | --- |
| `global` | Applies to the entire system (e.g., pulling new images, adding new services). |
| `service:{name}` | Applies only to a specific container (e.g., `service:alumni-portal`). |

**Available Actions:**

`manage`: Full control (Start, Stop, Restart, Delete). 
`view_logs`: Permission to stream live container logs via WebSocket.
`edit_configuration`: Ability to change CPU/RAM limits and port mappings. 
`edit_env`: Ability to update `.env` variables and trigger a restart.



**Inheritance Logic:**
The system implements logical inheritance. For example, if a user has `edit_configuration`, they implicitly get `view_configuration` rights.


---

### 5. CI/CD Workflow: Building & Pushing Images

To deploy apps on Orchestr8, they must be packaged as Docker images and pushed to the GitHub Container Registry (GHCR). We use a custom script and GitHub Action for this.

#### The Build Script (`build-push.sh`)

This script automates versioning. It queries the GitHub API to find the latest version tag (e.g., "0004") and increments it (e.g., "0005") automatically.

**Create this script in your application repo:**

```bash
#!/bin/bash
# Usage: ./build-push.sh <REPO_NAME> [VERSION]

# 1. Validate Repo Name
if [ -z "$1" ]; then
    echo "Error: REPO_NAME argument is required."
    echo "Usage: ./build-push.sh <REPO_NAME> [VERSION]"
    exit 1
fi

REPO_NAME="$1"
IMAGE_BASE="ghcr.io/{github username here}/$REPO_NAME"

# 2. Handle Versioning
if [ -n "$2" ]; then
    VERSION="$2"
else
    # Auto-increment logic
    # Fetches existing versions from GitHub API to determine the next tag
    # Requires GITHUB_PAT environment variable to be set
    LATEST=$(curl -s -H "Authorization: Bearer $GITHUB_PAT" \
             -H "Accept: application/vnd.github+json" \
             "https://api.github.com/users/{github username here}/packages/container/$REPO_NAME/versions" \
             | grep -o '"[0-9]\{4\}"' | sed 's/"//g' | sort -n | tail -1)
    
    if [ -z "$LATEST" ]; then
        VERSION="0001"
    else
        # Increments version by 1 and pads with zeros (e.g., 9 -> 0010)
        VERSION=$(printf "%04d" $((10#$LATEST + 1)))
    fi
    echo "Auto-incrementing to version: $VERSION"
fi

IMAGE_NAME="$IMAGE_BASE:$VERSION"

# Default context is root, can be customized.
BUILD_CONTEXT="."


# 4. Build and Push
echo "Building: $IMAGE_NAME from context: $BUILD_CONTEXT"
docker build -t "$IMAGE_NAME" "$BUILD_CONTEXT"
docker push "$IMAGE_NAME"

```

* Replave `{github username here}` with your username in the above code.

#### GitHub Actions Workflow

This workflow runs on every push to `main`. It logs into the registry and executes the script above.

**File:** `.github/workflows/docker-publish.yml`

```yaml
name: Docker Build & Push

on:
  push:
    branches: [ "main" ]

env:
  REGISTRY: ghcr.io

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write # Required to push to GHCR

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to the Container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Execute Build Script
        env:
          # Uses the automatic GITHUB_TOKEN for API authentication
          GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}
        run: |
          chmod +x build-push.sh
          # Pass the repo name specifically (e.g., "alumni-portal")
          ./build-push.sh "${{ github.event.repository.name }}"

```

#### Manual Linking (Crucial Step)

When a package is first pushed to GHCR, it is not automatically linked to the repository source code. This linkage is required for the "Auto-increment" script to find the correct package versions via the API.

1. Go to your GitHub Profile/Organization -> **Packages**.
2. Click on the newly pushed container image.
3. Go to **Package Settings** -> **Manage Actions access** (or "Connect Repository").
4. Select the repository that builds this image.

<img width="1062" height="301" alt="image" src="https://github.com/user-attachments/assets/0c7c0fa2-1496-495e-acb5-ce1d361ac806" />

---

### 6. Production Deployment (Systemd)

To ensure the Orchestr8 backend runs reliably and restarts on failure, deploy it as a Systemd service.

**File:** `/etc/systemd/system/orchestr8.service`

```ini
[Unit]
Description=Orchestr8 Backend Service
After=network.target docker.service
Requires=docker.service

[Service]
# Replace 'ubuntu' with your actual user
User=ubuntu
Group=docker
WorkingDirectory=/home/ubuntu/orchestr8-backend
# Path to Bun binary (run 'which bun' to confirm)
ExecStart=/usr/bin/bun run {your exact path to the built dist dir of the code}/index.js
Restart=always
RestartSec=3
Environment="PATH=/usr/bin:/usr/local/bin"
# Ensure the service can write to the Nginx managed dir
ReadWritePaths=/etc/nginx/sites-available/api-managed

[Install]
WantedBy=multi-user.target

```

**Enable and Start:**

```bash
sudo systemctl daemon-reload
sudo systemctl enable orchestr8
sudo systemctl start orchestr8
sudo systemctl status orchestr8

```

---

### 7. Accessing the Platform

Once the backend is running, you can access the User Interface.

* **UI URL:** `https://orchestr8-ui.devh.in/`
* **Default Admin:** Uses the `AUTH_USERNAME` and `AUTH_PASSWORD` defined in your `.env` file.
* **Database Users:** Additional users can be created via the API. These users are stored in `.dckr/data/users.sqlite` and can have restricted permissions.

### 8. Build and host your own frontend

Look into the UI dir for the frontend built in react.


#### Summary of Capabilities

**Start/Stop Services:** Controls Docker containers via API.
**Live Logs:** Streams logs using Hono streaming and Docker API.
**Environment Management:** Updates `.env` files safely and auto-restarts containers.
**Zero-Downtime Reloads:** Validates Nginx config (`nginx -t`) before reloading to prevent service outages and pushes healthy images only,
